---
title: volatile
excerpt: '并发'
tags: [并发]
categories: [并发]
comments: true
date: 2022-06-12 18:30:52
---

**volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。** --《Java并发编程的艺术》

volatile比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。

## volatile是如何保证可见性的？

在X86处理器下通过工具获取JIT编译器生成的汇编语言指令来查看对volatile进行写操作时，会多出一行汇编代码，Lock前缀。而Lock前缀的指令在多核处理器下会引发两件事情：
- 将当前处理器缓存行的数据写回到系统内存
- 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。

CPU在使用数据时，会先将数据读取到自己的缓存中（L1、L2等），然后再进行运算，但是操作完之后不一定什么时候再写回到内存。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在的缓存行数据写回到系统内存中。多处理器的环境下为了保证各个处理器缓存一致，就会实现缓存一致性协议，这个协议就是每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态。