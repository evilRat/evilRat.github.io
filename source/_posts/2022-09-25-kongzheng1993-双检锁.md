---
title: 双检锁
excerpt: 'Java'
tags: [Java]
categories: [Java]
comments: true
date: 2022-09-27 18:30:52
---

双重检查锁定模式（也被称为"双重检查加锁优化"，"锁暗示"（Lock hint）) 是一种软件设计模式用来减少并发系统中竞争和同步的开销。双重检查锁定模式首先验证锁定条件(第一次检查)，只有通过锁定条件验证才真正的进行加锁逻辑并再次验证条件(第二次检查)。

该模式在某些语言在某些硬件平台的实现可能是不安全的。有的时候，这一模式被看做是反模式。
它通常用于减少加锁开销，尤其是为多线程环境中的单例模式实现“惰性初始化”。惰性初始化的意思是直到第一次访问时才初始化它的值。

### Java双检锁实现单单例模式

```java
public class Singleton {
        private volatile static Singleton instance;
    
    private Singleton() {
        
    }
    
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

```

1. 为什么双重检验

如果多个线程同时到达第一个判断，此时isntance为null，多个线程通过这个判断，synchronized还可以加锁，同一时间只有一个线程可以执行同步代码块，同步代码块内再次判断，可以保证只有第一个执行同步代码块的线程会创建出实例。第一个检查的意义在于，实例化后，没必要每个线程都走同步代码块，这样会阻塞。

2. 为什么需要volatile

`instance = new Instance();`这行代码执行过程分为3个步骤：
- 在堆中开辟空间分配地址
- 根据类加载器初始化顺序进行初始化
- 将内存地址保存到栈中的变量

Java模型允许无序写入，可以会出现执行顺序为1-3-2，恰好此时其他线程在第一次if处判断，不是空，直接返回了。后面拿着null去执行肯定会出错。

而使用volatile，会在对instance操作时增加Lock前缀，相当于一个内存屏障，防止指令重排序，就不会出现1-3-2的情况。
