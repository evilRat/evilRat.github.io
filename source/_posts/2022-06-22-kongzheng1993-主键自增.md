---
title: 主键自增的原理
excerpt: '数据库'
tags: [数据库]
categories: [数据库]
comments: true
date: 2022-06-22 18:30:52
---

我们平常使用关系行数据库，总会创建一个与业务无关的主键列ID，并且这个id是自增的。记得刚工作前两年，还在用oracle数据库，oracle的自增要靠创建一个从1开始，步长为1的序列，每次要插入数据前，先通过这个序列获取id。

后来开始用MySQL了，每次建表上来就是一个`id int not null primary key auto_increment`，知道这样我们insert数据的时候id为空或者0，就可以出发id自增。说实话一直也没仔细去了解这其中的原理，今天就好好盘一下。

## 怎么实现自增

mysql中有两个设置：自增值`auto_increment_offset`和漂移值`auto_increment_increment`（也就是步长）

```shell
mysql> show variables like 'auto_increment%';
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| auto_increment_increment | 1     |
| auto_increment_offset    | 1     |
+--------------------------+-------+
2 rows in set (0.01 sec)
```

自增的算法：从auto_increment_offset开始，以auto_increment_increment为步长，持续增加。如果插入的id为x，当前的自增值为y：
- 如果x < y，那么这个表的自增值不变，如果x表里不存在，可以插入成功，如果存在报主键重复。
- 如果x>=y，那么需要把当前自增值修改为x

```
mysql> create table t_test(id int not null primary key auto_increment, a varchar(20) default null );
Query OK, 0 rows affected (0.04 sec)

mysql> insert into t_test(a) values ('test');
Query OK, 1 row affected (0.02 sec)

mysql> select * from t_test;
+----+------+
| id | a    |
+----+------+
|  1 | test |
+----+------+
1 row in set (0.01 sec)

mysql> insert into t_test values (3, 'test3');
Query OK, 1 row affected (0.03 sec)

mysql> select * From t_test;
+----+-------+
| id | a     |
+----+-------+
|  1 | test  |
|  3 | test3 |
+----+-------+
2 rows in set (0.00 sec)

mysql> insert into t_test(a) values ('test4');
Query OK, 1 row affected (0.02 sec)

mysql> select * From t_test;
+----+-------+
| id | a     |
+----+-------+
|  1 | test  |
|  3 | test3 |
|  4 | test4 |
+----+-------+
3 rows in set (0.00 sec)
```

## 怎么记住自增值

1. MyISAM引擎的自增值保存在数据文件中
2. InnoDB引擎的自增值，在5.7及之前的版本，自增值保存在内存里，没有持久化，每次重启后，第一次打开表的时候，都会去找max(id)，然后将max(id)+步长作为这个表当前的自增值。8.0版本以后，将自增值的变更记录在了redo log中，重启的时候依靠redo log恢复重启前的值。

## 自增锁

自增id锁并不是一个事务锁，而是每次申请完就马上释放，以便其他事务再申请
MySQL5.0版本时，自增锁的范围是语句级别的，也就是一个语句申请了一个表的自增锁，这个锁会在语句执行结束后释放。
MySQL5.1.22版本引入了一个新策略，新增参数innodb_autoinc_lock_mode，默认为1。
    - 0表示采用5.0时的策略，语句结束后释放锁；
    - 1表示普通insert语句，自增锁在申请之后马上释放，不用等到语句结束，而insert...select这样的批量插入数据的语句，自增锁还是要在语句结束之后才能释放。
    - 2表示所有申请自增主键的动作都是申请后就释放锁

2虽然提高了并发，但又可能造成数据不一致的问题。如果binlog_format=statement的话，两个session交替插入数据，binlog只能先记录其中一个session的日志，由于binlog记录的是statement，也就是sql，到时候根据binlog恢复数据，或者主从同步的话，id就不一致了。如果有这种情况，就应该innodb_autoinc_lock_mode设置为0或1，让批量插入的数据的语句执行完之后再释放锁。或者innodb_autoinc_lock_mode=2 && binlog_format=row，binlog不记录sql，而是记录数据修改的日志，也就不存在id不一致的问题了。


## 主键用完了会发生什么？

自增值不会再增加，再插入数据会报主键重复


https://www.jb51.net/article/221895.htm