---
title: 服务日志实现方式切换引起的问题
excerpt: 'log aspect filter'
tags: [SpringMVC, Logger]
categories: [SpringMVC, Logger]
comments: true
date: 2023-03-23 10:30:52
---

### 背景

最近工程框架切换，自测过程中，发现一个返回xml接口的响应报文后面跟着一个response的json。

如下图：
<img src="old.png">
<img src="new.png">

代码如下：

```java
    @GetMapping(value = "/{fileName}.xml")
    public Response paa(@PathVariable("fileName") String fileName, HttpServletResponse response) throws IOException {
        log.info("fileName={}", fileName);
        if(EmptyUtil.isEmpty(fileName) || !fileName.contains("-")){
            return Response.fail(StatusCode.EXCEPTION.getCode(),"文件名不存在");
        }
        fileName = fileName.replace(".xml", "").replace("paa-", "");
        String paaXml = pdiPaaConfigService.selectPaaXml(fileName, PaaConfigStatusEnum.PASS.getValue());
        if(EmptyUtil.isEmpty(paaXml)){
            return Response.fail(StatusCode.EXCEPTION.getCode(),"请确认该版本下的xml是否已经生成");
        }
        response.setCharacterEncoding("UTF-8");
        response.setContentType(ContentType.TEXT_XML.toString());
        InputStream resourceAsStream = IOUtils.toInputStream(paaXml, StandardCharsets.UTF_8);
        assert resourceAsStream != null;
        byte[] buffer = new byte[1024];
        int len = 0;
        ServletOutputStream sos = response.getOutputStream();
        while ((len = resourceAsStream.read(buffer)) > 0) {
            sos.write(buffer, 0, len);
        }
        sos.flush();
        sos.close();
        return Response.success();
    }
```


查看代码后可以发现，最后却是是返回了一个`Response.success()`，但是这个接口是想直接操作response的输出流，将xml内容返回。


### 分析

第一反应肯定是SpringMVC的MessageConverter。

从`org.springframework.web.servlet.DispatcherServlet#doDispatch`一路向北，在`org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod#invokeAndHandle`，如果returnValue（也就是上门的Response.success()）不为空，会通过`org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite#handleReturnValue`处理returnValue。

```java
	/**
	 * Invoke the method and handle the return value through one of the
	 * configured {@link HandlerMethodReturnValueHandler}s.
	 * @param webRequest the current request
	 * @param mavContainer the ModelAndViewContainer for this request
	 * @param providedArgs "given" arguments matched by type (not resolved)
	 */
	public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,
			Object... providedArgs) throws Exception {

		Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);
		setResponseStatus(webRequest);

		if (returnValue == null) {
			if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {
				mavContainer.setRequestHandled(true);
				return;
			}
		}
		else if (StringUtils.hasText(getResponseStatusReason())) {
			mavContainer.setRequestHandled(true);
			return;
		}

		mavContainer.setRequestHandled(false);
		Assert.state(this.returnValueHandlers != null, "No return value handlers");
		try {
			this.returnValueHandlers.handleReturnValue(
					returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
		}
		catch (Exception ex) {
			if (logger.isTraceEnabled()) {
				logger.trace(getReturnValueHandlingErrorMessage("Error handling return value", returnValue), ex);
			}
			throw ex;
		}
	}
```

handleReturnValue里会调用`org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor#writeWithMessageConverters(T, org.springframework.core.MethodParameter, org.springframework.http.server.ServletServerHttpRequest, org.springframework.http.server.ServletServerHttpResponse)`，遍历合适的MessageConverter来处理，最后就是把returnValue写到Response的body中，也就是追加到我们的xml后面了。

到这里我觉得，问题不在这里了，因为MessageConverter的处理都是一样的，将返回值写入Response的body里很正常，之前为啥没事儿呢？

这时候注意到这里的`HttpServletResponse`实现类是`ContentCachingResponseWrapper`，而老版本里是`ResponseFacade`。通过debug堆栈往前找，一直到一个类`public class LoggerFilter extends OncePerRequestFilter`，发现里面有这样的代码：

```java
ContentCachingRequestWrapper requestWrapper = new ContentCachingRequestWrapper(request);
ContentCachingResponseWrapper responseWrapper = new ContentCachingResponseWrapper(response);
```

去`ContentCachingRequestWrapper`看了一下：

```java

/**
 * {@link javax.servlet.http.HttpServletRequest} wrapper that caches all content read from
 * the {@linkplain #getInputStream() input stream} and {@linkplain #getReader() reader},
 * and allows this content to be retrieved via a {@link #getContentAsByteArray() byte array}.
 *
 * <p>Used e.g. by {@link org.springframework.web.filter.AbstractRequestLoggingFilter}.
 * Note: As of Spring Framework 5.0, this wrapper is built on the Servlet 3.1 API.
 *
 * @author Juergen Hoeller
 * @author Brian Clozel
 * @since 4.1.3
 * @see ContentCachingResponseWrapper
 */
public class ContentCachingRequestWrapper extends HttpServletRequestWrapper
```

注释中可以看到，这个包装类是为了方便读取Response的信息，而将`ServletInputStream`中的数据cache下来，以实现流中的数据重复读取。里面一个核心的方法就是：

```java
	/**
	 * Copy the cached body content to the response.
	 * @param complete whether to set a corresponding content length
	 * for the complete cached body content
	 * @since 4.2
	 */
	protected void copyBodyToResponse(boolean complete) throws IOException {
		if (this.content.size() > 0) {
			HttpServletResponse rawResponse = (HttpServletResponse) getResponse();
			if ((complete || this.contentLength != null) && !rawResponse.isCommitted()) {
				rawResponse.setContentLength(complete ? this.content.size() : this.contentLength);
				this.contentLength = null;
			}
			this.content.writeTo(rawResponse.getOutputStream());
			this.content.reset();
			if (complete) {
				super.flushBuffer();
			}
		}
	}
```


看到这里回想到老版本的日志呢？是怎么实现的？难道不需要去读取Resposne流中的数据吗？


一看还真是：

```java
@Slf4j
@Component
@Aspect
@Order(Ordered.HIGHEST_PRECEDENCE)
public class ServiceLogAspect {
    ......
        @Around("@within(org.springframework.stereotype.Controller) || @within(org.springframework.web.bind.annotation.RestController)")
    public Object around(ProceedingJoinPoint pjp) throws Throwable {
        HttpServletRequest request = ServletContextHolder.getRequest();
        if (Objects.isNull(request)) {
            return pjp.proceed();
        }
}

```

老版本的日志是通过切面，打印的也只是Controller和RestController中方法的参数和返回值。相比之下，新版本打印Request和Resposne的内容，更底层，更真实。

在MessageConverter将returnValue写入到`resposne.getBody()`中没问题，重点是新老版本的respose不同，一个是`ContentCachingRequestWrapper`，一个是`ResponseFacade`。

下面是`ServletServerHttpResponse`的getBody()方法：

```java
	@Override
	public OutputStream getBody() throws IOException {
		this.bodyUsed = true;
		writeHeaders();
		return this.servletResponse.getOutputStream();
	}
```

可以了解到就是返回对应的resposne的outputStream。而新旧版本的serveletResponse实现不同。

ResposneFacade就是返回真实的outputStream，而ContentCachingRequestWrapper则会返回一个包装的流`ResponseServletOutputStream`

```java
	@Override
	public ServletOutputStream getOutputStream() throws IOException {
		if (this.outputStream == null) {
			this.outputStream = new ResponseServletOutputStream(getResponse().getOutputStream());
		}
		return this.outputStream;
	}
```

### 真因

一个是真实的Resposne的流，另一个是假冒的流。再回到一开始业务代码，获取response的outputStream，然后写入xml数据，接着flush，最后close。重点就是这个close的是哪个流？

**老版本关闭的是真实的流，所以后面Response.success()并没有返回给客户端，因为流已经关闭了！而新版本关闭的并不是真实的response流，导致http链接还未断开，后面的Response.sucess()又经过MessageConverter写到了response的outputStream中，使得客户端接收到**


### 总结

通过这次分析，了解到了`org.springframework.web.util.ContentCachingResponseWrapper`这样一个Response的包装类，可以重复读取数据流，以后有相关需求可以用一下。