---
title: MongoDB笔记
excerpt: 'MongoDB'
tags: [MongoDB]
categories: [MongoDB]
comments: true
date: 2021-07-15 116:30:10
---

## 1. 主要特性

1. mongoDB的数据模型是面向文档的

2. 不像关系型数据库，每张表都有严格定义的Schema，规定了列和类型。mongoDB没有Schema，特别适合项目初期使用（表设计经常变化）。

3. 支持即时查询。

4. 二级索引。MongoDB中的二级索引也是用B树实现的。每个集合最多可以创建64个索引。它支持能在RDBMS中找到的各种索引，升序、降序、唯一性、复合键索引，甚至地理空间索引都支持。因为mongoDB和关系型数据库使用相同的索引数据结构。

5. 复制。mongoDB通过副本集（replica set）的拓扑结构提供了复制功能。副本集将数据分布在多台机器上以实现冗余，在服务器和网络故障时能提供自动故障转移。并且复制功能还能扩展数据库的读能力，如果有一个读密集型的应用，可以把数据库读操作分散到副本集集群中的各台机器上。**副本集由一个主节点和一个或多个从节点构成。**与我们熟悉的其他数据库的主从复制类似。副本集的主节点既能接受读操作又能接受写操作，但是从节点是只读的。**副本集与众不同的是它支持自动故障转移：如果主节点出现问题，集群会选择一个从节点自动将它提升为主节点。在先前的主节点恢复后会变成一个从节点**。

<img src = "image-20210715174420382.png"/>

6. 速度和持久性。用户可以选择写入语义，决定是否开启Journaling日志，通过这种方式来控制速度和持久性的平衡。默认所有的写操作都是`fire-and-forget`（射后不理）的，也就是通过TCP套接字发送，不要求数据库应答。如果用户需要获得应答，可以使用特殊的安全模式发起写操作，所有驱动都提供这个安全模式。该模式强制数据库做出应答，确保数据库正确无误地接收到了写操作。安全模式是可配置的，还可用于阻塞操作，直到写操作被复制到特定数量的服务器。对于高容量、低价值的数据（例如点击流和日志）,`fire-and-forget`风格的写操作是很理想的。对于重要的数据，则更倾向于安全模式。**在MongoDB 2.0中，Journaling日志是默认开启的。**有了这个功能，所有写操作都会被提交到一个只能追加的日志里。即使服务器非正常关闭（比如电源故障）,该日志也能保证重启服务器后MongoDB的数据文件被恢复到一致的状态。这是运行MongoDB最安全的方式。Journaling日志类似MySQL的InnoDB的事务日志，先写日志，再写内存，而后日志会同步到磁盘。先写日志，而不是直接去写主数据文件，是因为**顺序IO要比随机IO快的多**
7. 数据库扩展。**提升单一节点的硬件来进行扩展成为垂直扩展或者向上扩展**。垂直扩展的优势在于简单可靠，但是终有一天更强的服务器成本会让人望而却步。这时就应该考虑水平扩展或向外扩展了。**水平扩展不是提升单一节点的性能，而是将数据库分布到多台机器上**。MongoDB的水平扩展非常易于管理，通过基于范围的分区机制即**自动分片**来实现这一设计目标，自动分片机制会自动管理各个节点之间的数据分布。分片系统会处理分片节点的增加，帮助进行自动故障转移。单独的分片由一个副本集组成，其中包含至少两个节点，保证能够自动恢复，没有单点失败。

## MongoDB核心服务器

MongoDB是用C++编写的，由10gen积极维护。开源的。

1. 通过可执行文件mongod（windows上是mongodb.exe）可以运行核心服务器。mongod服务器进程使用一个自定义的二进制协议从网络套接字上接收命令，mongod进程的所有数据文件默认存储在`/data/db`里
2. mongod有多种运行模式，最常见的是作为副本集中的一员，因为推荐使用复制，通常副本集由两个副本组成，再加上一个部署在第三台服务器上的**仲裁进程**。
3. 对于MongoDB的自动分片架构而言，其组件包含配置为预先分片的副本集的mongod进程，以及特殊的元数据服务器，称为配置服务器（config server）。另外还有单独的名为mongos的路由服务器向适当的分片发送请求。
4. mongodb除了指定标准端口和数据目录，没有什么调优数据库的选项。但是这并不是缺陷，而是一个系统设计亮点，因为MongoDB的设计哲学指出，内存管理最好是由操作系统而非DBA或者应用程序开发者来处理，如此一来，数据文件通过mmap()系统调用被映射成了系统的虚拟内存，这一举措行之有效的将内存管理交给了操作系统内核。

## MongoDB工具

1. JavaScript Shell： MongoDB命令行shell是一个基于JavaScript的工具，用户管理数据库和操作数据。可执行文件mongo会加载shell并连接到指定的mongod进程。MongoDB Shell的功能和Mysql Shell差不多，但并不是使用SQL，大多数命令使用的是Javascript表达式。比如`db.users.insert({name: "Tom"})`。
2. 数据库驱动。
3. 命令行工具：
   1. mongodump和mongorestore：备份和恢复数据库的工具
   2. mongoexport和mongoimport：用来导入导出JSON、CSV和TSV数据
   3. mongosniff：一个网络嗅探工具，用来观察发送到数据库的操作。基本就是把网络上传输的BSON转换为易于人们阅读的Shell语句。
   4. mongostat：持续轮询MongoDB和系统以便提供有磅数的统计信息，包括每秒操作数、分配的虚拟内存数量以及服务器的连接数。

## 2. MongoDB JavaScript Shell

### 1. 通过shell增删改查

### 2. 索引

1. 创建一个大集合，因为mongoDB Shell是javaScript解释器，所以可以像下面一样使用js

   ```javascript
   for(i=0; i<200000; i++) {
       db.numbers.save({num: i});
   }
   ```

2. explain

   ```javascript
   db.numbers.find({num: {"$gt": 199995}}).explain()
   ```

   

3. 创建索引

   ```javascript
   // 创建索引
   db.numbers.ensureIndex({num: 1})
   // 查看索引
   db.numbers.getIndexes()
   ```

   

### 3. 基本管理

1. 获取数据库信息

   ```javascript
   // 显示系统上所有的数据库
   show dbs
   // 显示定义在当前数据库里的所有集合
   show collections
   // 获取数据库与集合更底层的统计数据
   db.stats()
   // 获取集合的统计数据
   db.numbers.stats()
   ```

   

2. 命令工作原理

MongoDB Shell会输出所有方法的实现，只要这些方法忽略括号就可以了。比如查看db.runCommand()的方法实现，输入db.runCommand就可以查看。

runCommand函数中的最后一行就是查询“$cmd”集合。

- 数据库命令是对特殊集合$cmd的查询。

- 查询选择器就是对命令本身的定义。

3. 获得帮助
   1. 通过tab不全命令
   2. 通过上面说的执行不带括号的方法名，查看方法实现

## 3. 使用MongoDB

### 1. 驱动是如何工作的

MongoDB驱动都有三个主要功能：

1. 生成MongoDB对象ID，这是存储在所有文档_id字段里的默认值
2. 驱动会把所有语言特定的文档描述和BSON互相转换，BSON是MongoDB使用的二进制数据格式
3. 使用MongoDB的网络协议通过TCP套接字与数据库通信

对象ID：对象ID不会重复，由12个字节构成，前四个字节是时间戳，接下来3个字节存储了机器ID，随后2个字节记录的进程ID，最后3个字节存储了进程局部的计数器，每次生成对象计数器都会加1。通过id可以获取创建的时间戳，精度是最接近的一秒钟。

BSON：是MongoDB中用来表示文档的二进制格式，即使存储格式，也是命令格式。BSON规范包含了19种数据格式，包含UTF-8字符串、32位和64位整数、双精度浮点数、布尔值、时间戳和UTC日期时间（datetime）。其他一部分类型是MongoDB特定的。比如对象ID就有自己的格式，还有模糊大字段的二进制类型等。

### 2. 数据的细节

1. 管理数据库

   MongoDB没有显示创建数据库的方法，而是在向集合写入数据的时候会自动创建，可以通过下面的方法删除数据库，但是这个操作一定要小心，因为这个操作是无法撤回的。

   ```javascript
   use garden
   db.dropDatabase();
   ```

2. 数据文件与空间分配

   创建数据库时，MongoDB会在磁盘上分配一组数据文件，把所有集合、索引和数据库的其他元数据保存在这些文件里。数据文件都被放置在启动mongod时指定的dbpath里。在未指定dbpath时，mongod会把文件全保存在data/db里：

   - .ns文件：namespaces，命名空间。每个集合和索引都有自己的命名空间。默认情况下，.ns文件大小固定16MB，大约可以存储24000个命名空间。也就是说数据库中的索引和集合的总数不能超过24000。
   - 集合与索引文件：从0开始的整数结尾。garden.0和garden.1。两个文件大小分别为64MB和128MB。之所以初始化这么大空间，是因为能让数据尽可能的连续存储，查询和更新数据时效率会高。向数据库添加数据时，MongoDB会继续分配更多的数据文件，而且每个文件都是上一个文件的两倍大，也就是garden.2会是256MB，直到预分配文件大小的上线2GB。

### 集合的细节

1. 管理集合

   可以像创建数据库一样，通过插入数据来隐式地创建集合，但是由于存在多种集合，所以MongoDB还提供了创建集合的命令。

   ```javascript
   db.createCollection("users"， {size: 2000})
   ```

   集合名是用它的命名空间名称来标志的，其中包含了它所属的数据库的名称，比如garden.users，这个完全限定集合名不能超过128个字符。

2. 固定集合（capped collection）

   固定集合原本是针对高性能日志场景设计的。他们与标准集合的区别在于其大小是固定的。一旦固定集合到达容量上限，后续的插入会覆盖集合中最先插入的文档。在只有最近的数据才有价值的情况下，这种设计避免了用户手工清理集合的烦恼。固定集合默认不为`_id`创建索引，这是为了优化性能，没有索引，插入会更快，如果需要`_id`索引，可以手动创建。在不定义索引的情况下，最好把固定集合当作用于顺序处理的数据结构，而非随机查询的数据结构。如果需要逆序输出，必须使用`$natural`排序操作符：

   ```javascript
   db.user.actions.find().sort({"$natural": -1})
   ```

   此外，固定集合还显示了CRUD操作，不能从固定集合中删除文档，也不能执行任何会增加文档大小的更新操作。

3. 系统集合

   类似mysql、oracle的系统表，system.namespace和system.indexes就属于这些特殊系统集合，它俩都是标准集合，但是MongoDB使用固定集合来做复制，每个副本集的成员都会把所有的写操作记录到一个特殊的oplog.rs固定集合里。从节点顺序读取这个集合的内容，再把这些新操作应用到自己的数据库里。

### 文档的细节

1. 为了可以正确序列化为BSON，键名必须是合法的：合法的键名由null结尾的字符串组成，最大长度为255字节，字符传可以包含任意ASCII字符的组合，但是不能以`$`开头，不能包含`.`,除了结尾处外不能包含`null`字节。可以用符号充当散列的键，因为他们在序列化时会被转换为等效的字符串。

2. RDBMS的列名属于元数据，和数据时分开存储的，而MongoDB的BSON不同，每个文档都会保存每个键名，所以尽量设置短小的键名。

3. BSON规定了三种数字类型：double、int和long。在动态语言里序列化整数时，驱动会自己决定时将其序列化为int还是long。实际上，只有一种常见情况需要显示地决定数字类型，那就是通过JavaScript Shell插入数字数据时。JavaScript天生就只支持一种数字类型--Number，它等价于IEEE的双精度浮点数。因此，如果希望在Shell里将一个数字保存为整数，需要使用NumberLong()或NumberInt()显示指出。

   ```javascript
   db.numbers.save({n: 5}); // double
   db.numbers.save({n: NumberLong(5)}); // long
   ```

   查询所有n为5的文档，会将上面两个文档一起返回。

   使用`$type`操作符来查询BSON类型，每种BSON类型都由1开始的整数来标识。双精度浮点数类型是1，64位整数类型是18。

   ```javascript
   db.numbers.find({n: {$type: 1}}); // 只能查到上面第一条文档
   db.numbers.find({n: {$type: 18}}); // 只能查到上面第二条文档
   ```

4. 自定义类型

   可以根据几个不同的原生BSON值，创建自己的虚拟类型。

5. 文档大小限制

   MonggoDB v2.0中BSON文档的大小被限制在16MB，两个原因：

   1. 防止开发者创建难看的数据模型。
   2. 性能相关。在服务器端查询大文档，将结果发送到客户端之前需要将文档复制到缓冲区，这个复制动作代价可能很大，尤其在客户端并不需要整个文档时。而且还要反序列化。。。

6. 批量插入

   实现构造多个文档的数组，随后将整个文档数组传递给insert方法。与单独返回一个对象ID有所不同，批量插入会返回所有插入文档的对象ID数组。批量插入理想的数量范围为10~200（具体情况还要看基准测试结果）。数据库单方面唯一的限制是单次插入操作不能超过16MB上限。

