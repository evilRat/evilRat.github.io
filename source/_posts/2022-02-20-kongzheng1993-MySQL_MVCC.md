---
title: MySQL MVCC
excerpt: 'mysql'
tags: [mysql]
categories: [mysql]
comments: true
date: 2022-01-09 18:30:52
---

# MySQL的MVCC、事务隔离和锁

原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）

## MVCC

MVCC，全称`Multi-Version Concurrency Control`，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。

记为一致性非锁定读，MySQL基于自己的***回滚机制**为并发场景的**读操作**做的一个优化。回滚机制也就是undo log，

`MVCC`的基本思路是对数据库的任何修改都不会直接覆盖之前的数据，而是产生一个新版副本与老版本共存，以此达到读取时可以**完全不加锁**的目的。在这句话中，“版本”是个关键词，你不妨将版本理解为数据库中每一行记录都存在两个看不见的字段：`CREATE_VERSION`和 `DELETE_VERSION`，这两个字段记录的值都是`事务ID`，`事务ID`是一个全局严格递增的数值，然后根据以下规则写入数据。

- 插入数据时：CREATE_VERSION 记录插入数据的事务 ID，DELETE_VERSION 为空。
- 删除数据时：DELETE_VERSION 记录删除数据的事务 ID，CREATE_VERSION 为空。
- 修改数据时：将修改数据视为“删除旧数据，插入新数据”的组合，即先将原有数据复制一份，原有数据的 DELETE_VERSION 记录修改数据的事务 ID，CREATE_VERSION 为空。复制出来的新数据的 CREATE_VERSION 记录修改数据的事务 ID，DELETE_VERSION 为空。

此时，如有另外一个事务要读取这些发生了变化的数据，将根据`隔离级别`来决定到底应该读取哪个版本的数据。

- 隔离级别是可重复读：总是读取 CREATE_VERSION 小于或等于当前事务 ID 的记录，在这个前提下，如果数据仍有多个版本，则取最新（事务 ID 最大）的。
- 隔离级别是读已提交：总是取最新的版本即可，即最近被 Commit 的那个版本的数据记录。

另外两个隔离级别都没有必要用到 MVCC，因为读未提交直接修改原始数据即可，其他事务查看数据的时候立刻可以看到，根本无须版本字段。可串行化本来的语义就是要阻塞其他事务的读取操作，而 MVCC 是做读取时无锁优化的，自然就不会放到一起用。

MVCC 是只针对“读+写”场景的优化，如果是两个事务同时修改数据，即“写+写”的情况，那就没有多少优化的空间了，此时加锁几乎是唯一可行的解决方案，稍微有点讨论余地的是加锁的策略是“乐观加锁”（Optimistic Locking）还是“悲观加锁”（Pessimistic Locking）。前面笔者介绍的加锁都属于悲观加锁策略，即认为如果不先做加锁再访问数据，就肯定会出现问题。相对地，乐观加锁策略认为事务之间数据存在竞争是偶然情况，没有竞争才是普遍情况，这样就不应该在一开始就加锁，而是应当在出现竞争时再找补救措施。这种思路被称为“乐观并发控制”（Optimistic Concurrency Control，OCC），囿于篇幅与主题的原因，就不再展开了，不过笔者提醒一句，没有必要迷信什么乐观锁要比悲观锁更快的说法，这纯粹看竞争的剧烈程度，如果竞争剧烈的话，乐观锁反而更慢。

## 隔离级别

MySQL有四种隔离级别，由低到高分别是：

- read uncommited 读取未提交数据
- read commited 读取已提交数据
- repeatable read 可重复读
- serializable 串行化

MySQL的默认隔离级别是repeatable read。

### 举例描述MVCC和隔离级别的关系

举例： A、B线程为写线程，C线程为读线程
repeatable read级别下：
A、C同时向一条数据发起了写和读的操作，C发起线程后（已开启事务了）sleep，A开始修改数据，在可重复读的隔离界别下，要先生成一版快照，修改之前的快照，也就是undo log，以便回滚，A线程修改完成后提交了，这时候存在2个版本，A线程结束。然后B线程来了，也是一个写线程，又产生了一个快照，对这条数据进行了写操作，commit后，B线程结束，这时候一共有3个版本，A线程之前到版本，A线程之后、B线程之前到版本，B线程之后到版本。这时候C线程sleep结束，C线程读到的是第一个版本的数据。

read commited:
同样是上面的例子，AC线程同时开启事务发起操作，C线程sleep，A线程写，A线程提交后，B线程过来修改完提交，C线程这个时候过来读，C线程读到的是最新的版本，也就是B提交的版本。

总结：repeatable read读取的是自己线程开始时的版本，read commited读取的是最新的版本。

read uncommited，还没有提交的数据就能读到，就没有必要使用版本管理了，直接就能读到其他线程修改的数据，直接操作一份数据就可以了。不需要MVCC。serializable，这个隔离级别下，所有的操作（读+写）都是加锁的，也就是所有线程顺序执行，并不会出现并发问题。

read commited能读到其他事物提交的数据，事物之间没有隔离，违背了食物的隔离性（ACID的I）。
repeatable read其他线程再怎么修改，C读取到的都是最初自己开启事务时的版本，也就做到了事务的隔离性。


### 不能隔离级别下存在的问题

read uncommited：会造成**脏读**、**幻读**和**不可重复读**，其他线程还没提交，你就能读到，这读到的数据时一种临时状态的数据，或者说是脏数据，我们称之为**脏读**。总结：脏读是在read uncommited事务隔离级别下的读取到其他线程未提交到数据。

read commited：会造成**幻读**和**不可重复读**。不可重复读可以理解为读取同一条数据，两次读取到的内容不一样。幻读可以理解为同一条sql的执行两次的到的数据量不一样。

repeatable read：会造成**幻读**，next key lock

serializable：可以解决以上所有问题。他存在的问题就是慢……


## 锁

InnoDB存储引擎实现了如下两种标准的行级锁：

- 共享锁（S Lock），允许事务读一行数据。

- 排他锁（X Lock），允许事务删除或更新一行数据。

如果一个事务T1已经获得了行r的共享锁，那么另外的事务T2可以立即获得行r的共享锁，因为读取并没有改变行r的数据，称这种情况为锁兼容（Lock Compatible）。但若有其他的事务T3想获得行r的排他锁，则其必须等待事务T1、T2释放行r上的共享锁——这种情况称为锁不兼容


InnoDB存储引擎有3种行锁的算法，其分别是：

- Record Lock：单个行记录上的锁

- Gap Lock：间隙锁，锁定一个范围，但不包含记录本身

- Next-Key Lock∶Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身

Record Lock总是会去锁住索引记录，如果InnoDB存储引擎表在建立的时候没有设置任何一个索引，那么这时InnoDB存储引擎会使用隐式的主键来进行锁定。

Next-Key Lock是结合了Gap Lock和Record Lock的一种锁定算法，在Next-Key Lock算法下，InnoDB对于行的查询都是采用这种锁定算法。