---
title: MySQL事务隔离级别
excerpt: ''
tags: [Java]
categories: [Java]
comments: true
date: 2020-04-17 00:30:52
---


## 什么是事务

事务是应用程序中一系列操作，所有操作必须全部完成，若有一个操作失败，都会使所有的操作撤销。

## ACID

事务具有四个特性：**原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）**。

- 原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做。
- 一致性。事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是**不一致的状态**。
- 隔离性。一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。
- 持续性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。

## MySQL的四种隔离级别

SQL标准定义了四种隔离级别，低级别的隔离一般支持更高的并发处理，并拥有更低的系统开销。

### Read Uncommitted （读取未提交内容）

在这个隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为他的性能也不比其他隔离级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。

### Read Committed （读取提交内容）

这个隔离级别是大多数数据库默认隔离级别（不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。

这种隔离级别也支持所谓的**不可重复读（Nonrepeatable Read）**，因为同一事物的其他实例在该实例处理期间可能会有新的commit，所以同一select可能返回不同结果。

### Repeatable Read （可重读）

这个是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行，不过理论上，这会导致**幻读（Phantom Read）**

幻读是指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新的数据行，当用户在读取该范围的数据行时，会发现有新的“幻影”行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC,Multiversion Concurrency Control）机制解决了该问题。

### Serializable （可串行化）

这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

**备注：**

这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：

- 脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。
- 可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的。通常针对数据更新（UPDATE）操作。
- 对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据更新（UPDATE）操作。
- 幻读是针对数据插入（INSERT）操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。

**在MySQL中，四种隔离级别，分别有可能产生的问题：**

隔离级别|脏读|不可重复读|幻读
-|:-:|:-:|:-:
Read uncommited|√|√|√
Read commited|×|√|√
Repeatable read|×|×|√
Serializable|×|×|×
