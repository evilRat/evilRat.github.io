---
title: 各种索引？
excerpt: ''
tags: [MySQL]
categories: [MySQL]
comments: true
date: 2020-04-29 00:30:52
---

## 各种索引？

总有面试官问，来说说索引种类？

索引种类？根据什么分类的？？？

“您说的是`单列索引`和`组合索引`？”
“回去等消息吧。。”

摸不透他在想什么。。

您倒是说个分类依据嘛。。

## 索引是什么？

索引类似大学图书馆建书目索引，可以提高数据检索的效率，降低数据库的IO成本。MySQL在300万条记录左右性能开始逐渐下降，虽然官方文档说500~800w记录，所以大数据量建立索引是非常有必要的。MySQL提供了Explain，用于显示SQL执行的详细信息，可以进行索引的优化。

之前看过一个网课，老师说的一句话让我醍醐灌顶，“索引说到底就是数据结构”，如果从这句话看，索引种类好像是有的说呢，也各种数据结构实现的索引。

**索引就是排序之后的数据结构，有顺序所以好查找喽**

## 几种查找方式

- **顺序查找：** 最基本的查询算法-复杂度O(n)，大数据量此算法效率糟糕。

- **二叉树查找(binary tree search)：** O(log2n)，数据本身的组织结构不可能完全满足各种数据结构。如果数据是单边增长的情况，就和顺序查找一样了。。如下图：
<img src="1216484-20190825001255129-2032384167.png">

- **hash索引：** 无法满足范围查找。哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。每一行会产生一个hash值，而且是唯一的，哈希索引将所有的哈希值存储在索引中，同时保存指向每个数据行的指针，这样就可以根据，索引中寻找对于哈希值，然后在根据对应指针，返回到数据行。这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。

- **红黑树(二叉平衡树)：** [复杂度O(h)]导致树高度非常高(平衡二叉树一个节点只能有左子树和右子树),逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，IO次数多查找慢,效率低。todo 逻辑上相邻节点没法直接通过顺序指针关联，可能需要迭代回到上层节点重复向下遍历找到对应节点，效率低。比二叉树好的是，可以限制单边增长的问题。

- **B-TREE(B树)：** 每个节点都是一个二元数组: [key, data]，所有节点都可以存储数据。key为索引key,data为除key之外的数据。
  - 检索原理：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或未找到节点返回null指针。
  - 缺点：
    1. 插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质。造成IO操作频繁。
    2. 区间查找可能需要返回上层节点重复遍历，IO操作繁琐。

    <img src="v2-2c2264cc1c6c603dfeca4f84a2575901_r.jpg">

- **B+Tree：** B-Tree的变种。与B-Tree相比，B+Tree有以下不同点：非叶子节点不存储data，只存储索引key；只有叶子节点才存储data。Mysql中B+Tree，在经典B+Tree的基础上进行了优化，增加了顺序访问指针。在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。这样就提高了区间访问性能。
  - 特点：
    1. B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；
    2. B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;
    3. B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。
    4. B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。
<img src="v2-5f069fd820637db1b877fdd6799a2b67_r.jpg">

## MySQL索引类型

Mysql目前主要有以下几种索引类型：FULLTEXT，HASH，BTREE，RTREE。

1. FULLTEXT：即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%"这类针对文本的模糊查询效率较低的问题。

2. HASH：由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。

3. BTREE：BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。

4. RTREE：RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。相对于BTREE，RTREE的优势在于范围查找。


## MySQL索引种类：

1. 普通索引：仅加速查询
2. 唯一索引：加速查询、列值唯一（可以有null）
3. 主键索引：加速查询、列值唯一（不可以有null）、表中只有一个主键索引
4. 组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。
5. 全文索引：对文本的内容进行分词，进行搜索，老版本只能用在MyISAM，新版本InnoDB也有了

```
索引合并：使用多个单列索引组合搜索
覆盖索引：select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖
```

```sql
--创建普通索引
CREATE INDEX index_name ON table_name(col_name);
--创建唯一索引
CREATE UNIQUE INDEX index_name ON table_name(col_name);
--创建主键索引
ALTER TABLE table_name ADD PRIMARY KEY (column);
--创建普通组合索引
CREATE INDEX index_name ON table_name(col_name_1,col_name_2);
--创建唯一组合索引
CREATE UNIQUE INDEX index_name ON table_name(col_name_1,col_name_2);
--创建全文索引
CREATE FULLTEXT INDEX ft_email_name ON student(name)；
```

## 索引带来的问题

- 创建索引是为产生索引文件的，占用磁盘空间
- 索引文件是一个二叉树类型的文件，可想而知我们的dml操作同样也会对索引文件进行修改，所以性能会下降
- 。。。
  
所以我们应该根据实际情况建立索引，不能盲目。