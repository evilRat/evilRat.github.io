---
title: Ribbon重试机制的意义之一：弥补EurekaAP最终一致性
excerpt: 'netty'
tags: [netty]
categories: [netty]
comments: true
date: 2023-01-30 10:30:52
---

# 背景

随着公司业务量增加，服务qps随之增加。上线发布过程中偶尔报出：“Error creating bean with name 'xxxx': Singleton bean creation not allowed while singletons of this factory are in destruction...”。

# 原因

## 发布过程分析

渐进发布过程：会先销毁一部分pod，然后用新镜像启动相同数量的pod，待新pod启动完成，再销毁剩下的pod，启动剩余的pod。应该是发布过程中，有请求去访问了已经开始销毁的pod（connection refuse等），或者服务没有处理完请求就开始销毁（Error creating bean...）。

## Eureka

在这个过程中，eureka剔除服务实例的时机是连续3次心跳失败，在这期间eureka的保护模式会依然提供已销毁节点的ip。这是Eureka实现的服务治理机制强调了CAP原理中的AP，即可用性与可靠性，它与ZooKeeper这类强调CP的服务治理框架最大的区别就是，Eureka为了实现更高的服务可用性，牺牲了一定的一致性，在极端情况下它宁愿接受故障实例也不要丢掉它认为“健康”的实例。

### 自我保护机制

Eureka服务端为了防止Eureka客户端本身是可以正常访问的，但是由于网路通信故障等原因，造成Eureka服务端失去于客户端的连接，从而形成的不可用。因为网络通信是可能恢复的，但是Eureka客户端只会在启动时才去服务端注册。如果因为网络的原因而剔除了客户端，将造成客户端无法再注册到服务端。极端情况下，Eureka还有自我保护机制。

如何选择关闭还是开启自我保护机制？
Eureka服务端默认情况下是会开启自我保护机制的。但我们在不同环境应该选择是否开启保护机制。
- 一般情况下，我们会选择在 开发环境下关闭自我保护机制，而在生产环境下启动自我保护机制。
- 开发环境下，我们我们启动的服务数量较少而且会经常修改重启。如果开启自我保护机制，很容易触发Eureka客户端心跳占比低于85%的情况。使得Eureka不会剔除我们的服务，从而在我们访问的时候，会访问到可能已经失效的服务，导致请求失败，影响我们的开发。

在生产环境下，我们启动的服务多且不会反复启动修改。环境也相对稳定，影响服务正常运行的人为情况较少。适合开启自我保护机制，让Eureka进行管理。

## Ribbon重试机制

由于Spring Cloud Eureka在可用性与一致性上的取舍，不论是由于触发了保护机制还是服务剔除的延迟，引起服务调用到故障实例等时候，我们还是希望能够增强对这类问题的容错。所以在服务调用时通常会加入一些重试机制。ribbon的MaxAutoRetries和MaxAutoRetriesNextServer配置可以实现：当访问到故障请求到时候，他会再尝试访问一次当前实例（次数由MaxAutoRetries配置），如果不行，就换一个实例进行访问，如果还是不行，再换一次（更换次数由MaxAutoRetriesNextServer配置），如果依然不行，返回失败信息。

# 思考

Ribbon的重试机制可以弥补Eureka的C的缺失，通过重试达到最终一致。但是在复杂的分布式系统中，由于调用链过长可能会产生调用风暴，给正常的服务实例带来巨大的压力。所以还需要配合熔断来保护健康的实例。而且重试的情况需要确认，比如读超时（read timeout）最好是不要重试，即使接口都幂等，也会无端增加系统的压力。

