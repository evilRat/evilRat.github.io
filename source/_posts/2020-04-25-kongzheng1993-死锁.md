---
title: 死锁
excerpt: ''
tags: [多线程]
categories: [多线程]
comments: true
date: 2020-04-25 00:30:52
---

## 什么是死锁

<img src="v2-fccd6ccc07c0caf2643f324cdb7856e7_b.jpg">

死锁的本质，举个例子如果此时有一个线程 A ，按照先获持有锁 a 再获取锁 b的顺序获得锁，同时另外一个线程 B，按照先获取锁 b 再获取锁 a 的顺序获取锁。它们都像申请对方的资源却不得，所以会相互等待，进入死锁状态。

## 条件

产生死锁必须具备以下四个条件：

- **互斥条件**：该资源同一时刻只能由一个线程占用。
- **请求与保持条件**：一个进程因为请求资源而阻塞时，不会释放已经获得的资源。
- **不可剥夺条件**：线程已经获得的资源在未主动释放前不能被其他线程强行剥夺。
- **循环等待条件**：若干个线程之间形成一种头尾相接的循环等待资源关系。

## 如何避免死锁问题

我们只要破坏了死锁必须的四个条件之一就可以避免产生死锁问题。

- 破坏互斥条件：这里很难做到，毕竟线程安全问题就是要让线程对资源的访问互斥，不然干嘛用锁呢。
- 破坏请求与保持条件：可以让线程一次性申请到它需要的全部资源。这样会严重降低资源利用率。
- 破坏不可剥夺条件：申请新的资源前先释放掉之前占有的资源，如果后面还需要之前的资源，到时候再申请。也可以在申请新资源时判断，申请到继续执行，申请不到主动释放持有的资源，不要阻塞其他线程。
- 破坏循环等待条件：资源排序，按照一定的顺序申请资源，反序释放资源。
  
## 排查死锁问题

1. `jps`或`ps -ef | grep java`查看java进程
2. `jstack`查看线程堆栈信息，如果有`Found one Java-level deadlock`等字样，表示我们写的程序发生了死锁。查看并记录发生死锁等代码位置。
3. 优化代码。

**其他工具：**

- **jconsole**：jdk提供了一个可视化等工具，可以排查一些程序问题
- **jvisualvm**：jdk提供等可视化问题排查工具。可以生成dump来查看堆栈信息。