---
title: DDD
excerpt: '架构'
tags: [架构]
categories: [架构]
comments: true
date: 2022-03-10 18:30:52
---

DDD不是什么新鲜玩意，早在2004年著名建模专家eric evans在其书籍《领域驱动设计—软件核心复杂性应对之道》就提出了。

不过那时候，国内软件业务还没有这么复杂，没有人在意软件设计。

## 杜绝软件退化，两顶帽子

随着软件行业的发展，软件规模越来越大，业务越来越复杂，代码越来越多，越来越乱，屎山就是这么来的……

于是微服务来了，小而专，高内聚。

软件设计质量最高的时候，就是第一版设计。从那之后的每一次需求变更，就开始打乱、破坏之前的设计，随着时间的推迟，维护成本越来越高。

开放-封闭原则：
- 开放原则：对功能扩展是开放的，当系统需求发生变更时，可以对软件功能进行扩展，使其满足用户新的需求。open for extension
- 封闭原则：对代码的修改是封闭的，在修改软件的同时，不要影响到系统原有的功能，所以应当在不修改原有代码的基础上实现新功能。close for modification

**软件的本质就是对真实世界的模拟，软件中业务逻辑是否正确的唯一标准就是是否与真实世界一致。**

比如一段电商行业支付相关的代码，一个PayService中有一个payOff方法，初版的需求就是一个简单的根基商品的总价进行支付，但是新需求来了，要求支持各种折扣功能（限时折扣、限量折扣、对某种商品折扣、对某个商品折扣、不折扣）。如果上来就干，可能就是一顿if/else，判断折扣类型计算支付金额。这样的代码，就增加了维护的难度，当更多这样的代码聚集到一起的时候，几百上千行的支付方法，会让开发者难以下手。

如果调整软件的程序结构，由简单的程序结构转变为复杂的程序结构，对应着现实世界的简单需求转变为复杂需求。

要保持软件设计质量不退化，必须在每次需求变更的时候，对原有的程序结构适当的进行调整。

在实现新需求时，要采用两顶帽子的方式：
1. 在不添加新功能的前提下，重构代码，调整原有程序结构，以适应新功能
2. 实现新的功能

还是上面的需求，如果不动之前的代码，而是给PayService增加接口，payOff方法实现各不相同。如果后期那种折扣需求变化，就修改哪个实现类；如果后期要增加折扣方式，就增加实现类。

如果每次的灵活设计只能应对一种需求变更，其实作用不大，最后的结果可能是我们期望的变化没有发生，所做的设计都成了摆设，这次设计也就成了过度设计。每次设计应该只为当前的需求设计，使其刚刚满足当前需求。

每次变更，都还原到真实世界中，根据真实世界进行设计。

像图中描述的，将真实世界和软件世界联系起来

<img src="entity_model.png">

- 真实世界有什么事物，软件世界就有什么对象
- 真实世界的事物有什么行为，软件世界的对象就有什么方法
- 真实世界的事物间有什么关系，软件世界中对象就有什么关联

软件发展的规律就是逐步由简单软件向复杂软件转变，在这个过程中，需要有两顶帽子，适时的对程序结构进行调整，再实现新需求，只有这样才能保证软件不退化。关于具体两顶帽子怎么做，DDD给了思路：每次变更时，先回到领域模型，基于业务进行领域模型的变更，然后再根据领域模型的变更指导程序的变更。

## 单一指责原则

**单一指责原则：软件系统中的每个元素只完成自己职责范围内的事，而将其他的事交给别人去做，我只是去调用**

一个指责就是软件变化的原因。

什么事高质量的代码？**当用户提出一个需求时，为了实现这个变更而修改软件的成本越低，软件设计的质量就越高**
怎样才能在每次变更的时候都只修改一个模块就能实现需求呢？需要平时不断的整理代码，将因同一个原因而变更的代码都放到一起，将不同原因而变更的代码放在不同的模块，不同的类中。这样当因为一个原因而修改代码时，需要修改的代码都在同一个模块、同一个类中，修改范围就小了。维护成本降低了，设计质量就提高了。

单一指责原则要求我们在维护软件的过程中不断的整理代码，将软件变化同一个原因的代码放在一起，将软件变化不同原因的代码分开放。

## DDD在数据库设计上的落地

领域模型设计是需求分析人员和设计开发人员共同的产物

    领域对象持久化存储的设计思想：
    将暂时不用的领域对象从内存中持久化到磁盘中，再次使用这个领域对象时，通过key值到数据库查找到这条记录，将其恢复成领域对象，应用程序继续使用它。以后数据库就没必要用关系型数据库了，可以通过nosql或者大数据平台，数据库的设计也可能不用遵守第三范式了，日后系统大数据转型的时候成本就更低了。

DDD的数据库设计变成了**以领域模型为核心，如何将领域模型转换成数据库设计的过程**

也就是程序中的类转换成数据库的表的过程。

- 在设计过程中，领域模型中，不论对象还是属性，在命名时都采用中文
- 在数据库设计时，要细化为英文命名，或者汉语拼音首字母，同时要确定字段类型与是否为空等其他属性。

如果将领域模型中的继承关系转换成数据库设计呢？
1. 如果继承关系的子类不多，并且每个子类的个性化字段不多，则可以用一个表来表示这种继承关系，用一个字段（类型）标识这条记录属于哪个子类，这个字段前面罗列的时父类的字段，这个字段的后面依次罗列各个子类的个性化字段，这样的优点时比较简单，整个继承关系的数据全部保存在这个表里，但是如果子类个性化字段太多，或导致很多字段为空，浪费空间，造成“表稀疏”。
2. 设计为多个表，父类的字段在每个表中都冗余，每个表的主键相同。如果业务总是将各个子类分开查询，这种设计就很合适，但是如果业务需要同时查询多个子类的数据，这种情况就不合适了。
3. 如果多种类型需要同时查询，而且各个字表的个性化字段比较多，前两种方法都不合适的时候，可以采用将父类字段作为一个表，各个子类分别有各自的表，主键与父表相同，当分页查询的时候，只查询父类的表，当查看详细信息的时候，再根据主键和类型字段去查询子类的表。

关系型数据库和NoSQL数据库：
- 我们平常用的还是mysql这种关系型数据库，遵循第三范式，使得数据库能够大幅度降低冗余，但数据库查询需要频繁使用join操作，在高并发场景下性能地下
- 将需要join的查询在写入数据表前先进行join操作，直接写到一张单表中进行分布式存储，这张表称为“宽表”

NoSQL数据库在设计时的套路就是尽量在单表中存储更多的字段，避免数据查询中的join操作，即使有很多字段是空的，也不会占用字段。

**因为NoSQL一版都是no schema的，而且空字段在序列化是就被过滤掉了，不会持久化到硬盘，也不存在所谓的浪费空间，所以继承关系就直接使用上面第一中方法就可以了。**


## 领域模型如何指导程序设计

服务：标识的是在领域对象之外的操作和行为，接受用户的请求和执行某些操作。当用户在系统界面操作，会向系统发起请求，“服务”去接收这些请求，然后根据需求去执行相应的方法，也就是操作实体和值对象，在所有的操作完成后，将实体和值对象持久化到数据库中。


实体

值对象



https://www.bilibili.com/video/BV1PM4y1L7Nh?p=5&spm_id_from=pageDriver  1:40
