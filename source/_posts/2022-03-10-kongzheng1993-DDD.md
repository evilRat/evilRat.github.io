---
title: DDD
excerpt: '架构'
tags: [架构]
categories: [架构]
comments: true
date: 2022-03-10 18:30:52
---

DDD不是什么新鲜玩意，早在2004年著名建模专家eric evans在其书籍《领域驱动设计—软件核心复杂性应对之道》就提出了。

不过那时候，国内软件业务还没有这么复杂，没有人在意软件设计。

随着软件行业的发展，软件规模越来越大，业务越来越复杂，代码越来越多，越来越乱，屎山就是这么来的……

于是微服务来了，小而专，高内聚。

软件设计质量最高的时候，就是第一版设计。从那之后的每一次需求变更，就开始打乱、破坏之前的设计，随着时间的推迟，维护成本越来越高。

开放-封闭原则：
- 开放原则：对功能扩展是开放的，当系统需求发生变更时，可以对软件功能进行扩展，使其满足用户新的需求。open for extension
- 封闭原则：对代码的修改是封闭的，在修改软件的同时，不要影响到系统原有的功能，所以应当在不修改原有代码的基础上实现新功能。close for modification

**软件的本质就是对真实世界的模拟，软件中业务逻辑是否正确的唯一标准就是是否与真实世界一致。**

比如一段电商行业支付相关的代码，一个PayService中有一个payOff方法，初版的需求就是一个简单的根基商品的总价进行支付，但是新需求来了，要求支持各种折扣功能（限时折扣、限量折扣、对某种商品折扣、对某个商品折扣、不折扣）。如果上来就干，可能就是一顿if/else，判断折扣类型计算支付金额。这样的代码，就增加了维护的难度，当更多这样的代码聚集到一起的时候，几百上千行的支付方法，会让开发者难以下手。

如果调整软件的程序结构，由简单的程序结构转变为复杂的程序结构，对应着现实世界的简单需求转变为复杂需求。

要保持软件设计质量不退化，必须在每次需求变更的时候，对原有的程序结构适当的进行调整。

在实现新需求时，要采用两顶帽子的方式：
1. 在不添加新功能的前提下，重构代码，调整原有程序结构，以适应新功能
2. 实现新的功能

还是上面的需求，如果不动之前的代码，而是给PayService增加接口，payOff方法实现各不相同。如果后期那种折扣需求变化，就修改哪个实现类；如果后期要增加折扣方式，就增加实现类。

如果每次的灵活设计只能应对一种需求变更，其实作用不大，最后的结果可能是我们期望的变化没有发生，所做的设计都成了摆设，这次设计也就成了过度设计。每次设计应该只为当前的需求设计，使其刚刚满足当前需求。

每次变更，都还原到真实世界中，根据真实世界进行设计。

像图中描述的，将真实世界和软件世界联系起来

<img src="entity_model.png">

- 真实世界有什么事物，软件世界就有什么对象
- 真实世界的事物有什么行为，软件世界的对象就有什么方法
- 真实世界的事物间有什么关系，软件世界中对象就有什么关联

软件发展的规律就是逐步由简单软件向复杂软件转变，在这个过程中，需要有两顶帽子，适时的对程序结构进行调整，再实现新需求，只有这样才能保证软件不退化。关于具体两顶帽子怎么做，DDD给了思路：每次变更时，先回到领域模型，基于业务进行领域模型的变更，然后再根据领域模型的变更指导程序的变更。