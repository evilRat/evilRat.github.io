---
title: DDD
excerpt: '架构'
tags: [架构]
categories: [架构]
comments: true
date: 2022-03-10 18:30:52
---

DDD不是什么新鲜玩意，早在2004年著名建模专家eric evans在其书籍《领域驱动设计—软件核心复杂性应对之道》就提出了。

不过那时候，国内软件业务还没有这么复杂，没有人在意软件设计。

## 杜绝软件退化，两顶帽子

随着软件行业的发展，软件规模越来越大，业务越来越复杂，代码越来越多，越来越乱，屎山就是这么来的……

于是微服务来了，小而专，高内聚。

软件设计质量最高的时候，就是第一版设计。从那之后的每一次需求变更，就开始打乱、破坏之前的设计，随着时间的推迟，维护成本越来越高。

开放-封闭原则：
- 开放原则：对功能扩展是开放的，当系统需求发生变更时，可以对软件功能进行扩展，使其满足用户新的需求。open for extension
- 封闭原则：对代码的修改是封闭的，在修改软件的同时，不要影响到系统原有的功能，所以应当在不修改原有代码的基础上实现新功能。close for modification

**软件的本质就是对真实世界的模拟，软件中业务逻辑是否正确的唯一标准就是是否与真实世界一致。**

比如一段电商行业支付相关的代码，一个PayService中有一个payOff方法，初版的需求就是一个简单的根基商品的总价进行支付，但是新需求来了，要求支持各种折扣功能（限时折扣、限量折扣、对某种商品折扣、对某个商品折扣、不折扣）。如果上来就干，可能就是一顿if/else，判断折扣类型计算支付金额。这样的代码，就增加了维护的难度，当更多这样的代码聚集到一起的时候，几百上千行的支付方法，会让开发者难以下手。

如果调整软件的程序结构，由简单的程序结构转变为复杂的程序结构，对应着现实世界的简单需求转变为复杂需求。

要保持软件设计质量不退化，必须在每次需求变更的时候，对原有的程序结构适当的进行调整。

在实现新需求时，要采用两顶帽子的方式：
1. 在不添加新功能的前提下，重构代码，调整原有程序结构，以适应新功能
2. 实现新的功能

还是上面的需求，如果不动之前的代码，而是给PayService增加接口，payOff方法实现各不相同。如果后期那种折扣需求变化，就修改哪个实现类；如果后期要增加折扣方式，就增加实现类。

如果每次的灵活设计只能应对一种需求变更，其实作用不大，最后的结果可能是我们期望的变化没有发生，所做的设计都成了摆设，这次设计也就成了过度设计。每次设计应该只为当前的需求设计，使其刚刚满足当前需求。

每次变更，都还原到真实世界中，根据真实世界进行设计。

像图中描述的，将真实世界和软件世界联系起来

<img src="entity_model.png">

- 真实世界有什么事物，软件世界就有什么对象
- 真实世界的事物有什么行为，软件世界的对象就有什么方法
- 真实世界的事物间有什么关系，软件世界中对象就有什么关联

软件发展的规律就是逐步由简单软件向复杂软件转变，在这个过程中，需要有两顶帽子，适时的对程序结构进行调整，再实现新需求，只有这样才能保证软件不退化。关于具体两顶帽子怎么做，DDD给了思路：每次变更时，先回到领域模型，基于业务进行领域模型的变更，然后再根据领域模型的变更指导程序的变更。

## 单一指责原则

**单一指责原则：软件系统中的每个元素只完成自己职责范围内的事，而将其他的事交给别人去做，我只是去调用**

一个指责就是软件变化的原因。

什么事高质量的代码？**当用户提出一个需求时，为了实现这个变更而修改软件的成本越低，软件设计的质量就越高**
怎样才能在每次变更的时候都只修改一个模块就能实现需求呢？需要平时不断的整理代码，将因同一个原因而变更的代码都放到一起，将不同原因而变更的代码放在不同的模块，不同的类中。这样当因为一个原因而修改代码时，需要修改的代码都在同一个模块、同一个类中，修改范围就小了。维护成本降低了，设计质量就提高了。

单一指责原则要求我们在维护软件的过程中不断的整理代码，将软件变化同一个原因的代码放在一起，将软件变化不同原因的代码分开放。

## DDD在数据库设计上的落地

领域模型设计是需求分析人员和设计开发人员共同的产物

    领域对象持久化存储的设计思想：
    将暂时不用的领域对象从内存中持久化到磁盘中，再次使用这个领域对象时，通过key值到数据库查找到这条记录，将其恢复成领域对象，应用程序继续使用它。以后数据库就没必要用关系型数据库了，可以通过nosql或者大数据平台，数据库的设计也可能不用遵守第三范式了，日后系统大数据转型的时候成本就更低了。

DDD的数据库设计变成了**以领域模型为核心，如何将领域模型转换成数据库设计的过程**

也就是程序中的类转换成数据库的表的过程。

- 在设计过程中，领域模型中，不论对象还是属性，在命名时都采用中文
- 在数据库设计时，要细化为英文命名，或者汉语拼音首字母，同时要确定字段类型与是否为空等其他属性。

如果将领域模型中的继承关系转换成数据库设计呢？
1. 如果继承关系的子类不多，并且每个子类的个性化字段不多，则可以用一个表来表示这种继承关系，用一个字段（类型）标识这条记录属于哪个子类，这个字段前面罗列的时父类的字段，这个字段的后面依次罗列各个子类的个性化字段，这样的优点时比较简单，整个继承关系的数据全部保存在这个表里，但是如果子类个性化字段太多，或导致很多字段为空，浪费空间，造成“表稀疏”。
2. 设计为多个表，父类的字段在每个表中都冗余，每个表的主键相同。如果业务总是将各个子类分开查询，这种设计就很合适，但是如果业务需要同时查询多个子类的数据，这种情况就不合适了。
3. 如果多种类型需要同时查询，而且各个字表的个性化字段比较多，前两种方法都不合适的时候，可以采用将父类字段作为一个表，各个子类分别有各自的表，主键与父表相同，当分页查询的时候，只查询父类的表，当查看详细信息的时候，再根据主键和类型字段去查询子类的表。

关系型数据库和NoSQL数据库：
- 我们平常用的还是mysql这种关系型数据库，遵循第三范式，使得数据库能够大幅度降低冗余，但数据库查询需要频繁使用join操作，在高并发场景下性能地下
- 将需要join的查询在写入数据表前先进行join操作，直接写到一张单表中进行分布式存储，这张表称为“宽表”

NoSQL数据库在设计时的套路就是尽量在单表中存储更多的字段，避免数据查询中的join操作，即使有很多字段是空的，也不会占用字段。

**因为NoSQL一版都是no schema的，而且空字段在序列化是就被过滤掉了，不会持久化到硬盘，也不存在所谓的浪费空间，所以继承关系就直接使用上面第一中方法就可以了。**


## 领域模型如何指导程序设计

**服务**：标识的是在领域对象之外的操作和行为，接受用户的请求和执行某些操作。当用户在系统界面操作，会向系统发起请求，“服务”去接收这些请求，然后根据需求去执行相应的方法，也就是操作实体和值对象，在所有的操作完成后，将实体和值对象持久化到数据库中。


**实体**：通过一个唯一标识字段来区分真实世界中的每一个个体的领域对象。

**值对象**：代表的是真实世界中那些一成不变的、本质性的事物，这样的领域对象叫做“值对象”。

    可变性是实体的特点，不变性是值对象的本质。

将业务领域模型转换为程序设计思路：
- 贫血模型
- 充血模型

贫血模型，就是在软件设计中，有很多POJO对象，它们除了有一堆get/set方法，几乎没有任何业务逻辑。pojo对象去调用对应的service去完成业务逻辑。

充血模型，在领域对象中直接实现业务的逻辑操作。

充血模型保持了领域模型的原貌，可以比较直接地映射成程序的变更，代码修改起来比较直接。保持了对象的封装性，使得领域模型在面临多态、继承能复杂结构时，易于变更。

贫血模型相对充血模型更加简单易行，充血模型对设计和架构能力要求更高。

简单来说：贫血模型的业务逻辑在service中实现，充血模型的业务逻辑在领域对象中实现

取长补短，合理使用：
**将需要封装的业务逻辑放到领域对象中，按照充血模型去设计；除此之外的其他业务逻辑放到service中，按照贫血模型去设计**

哪些业务逻辑要用充血模型：
- 在领域模型中出现了类似继承、多态的情况
- 在软件设计的过程中需要将一些类型或者编码进行转换
- 希望在软件设计中能更好地表现领域对象之间的关系
- “聚合”，在真实世界中那些代表整体与部分的事物


**聚合**：表达的是真实世界中整体与部分的关系，比如订单与订单明细。一般代码中都会将订单明细对象集合作为订单对象的一个属性，也就是将订单明细聚合到了订单中。使用时就只拿到一个订单对象，订单明细作为订单的属性来使用，对于调用方，感知不到明细对象的存在。当整体不存在时，部分就变的没有意义。整体被称为**聚合根**，是外部访问的唯一入口。增删改的业务可以采用领域驱动设计，只能通过聚合根来访问数据，但是在分析汇总场景下，直接使用sql查询。

**仓库Repository**：领域驱动设计会实现一个仓库（Repository）去完成对数据库的操作。比如创建订单时，把新增订单和新增订单明细两个操作放到同一个事务中，就是将OrderDao#insert和OrderItemDao#insertList放到同一个事务中，供外部调用。

**工厂**：与设计模式中的工厂不同。设计模式中的工厂是将被调用方设计成一个接口下的多个实现，将这些实现放入工厂中，工厂负责通过key找到对应的实现类，创建出来，返回给调用方，从而降低了调用方与被调方的耦合度。而DDD中的工厂是装配创建领域对象，是领域对象生命周期的起点。比如系统要根据ID装载一个订单，订单仓库将任务交给订单工厂，订单工厂分别调用订单DAO、订单明细DAO、用户DAO去进行查询，将订单明细对象和用户对象分别set到订单对象的订单明细和用户属性中，订单工厂将装配好的订单对象返回给订单仓库。

DDD的仓库应该被抽象成一个存放领域对象的地方，一般情况下，我们将数据持久化到数据库，是一种实现。所以为了可以快速装载，或者最近会重复使用同一个领域对象，仓库可以实现缓存的功能，当客户程序需要获取某个领域对象时，可以先到缓存中获取。

通过仓库与工厂，对原有的DAO进行了一层封装，在保存、装载、查询等操作时，加入了聚合、装备等操作，并将这些操作封装起来，对上层的客户程序屏蔽。

**工厂和仓库是聚合的实现。传统DAO的设计是一种贫血设计，而工厂和仓库的设计是一种充血设计。**



## 如何进行领域驱动设计

业务总是有不同的场景，每种场景下的领域对象也各不相同，领域对象之间会相互联系。正确的设计思路应该是将整个系统划分为许多相对独立的业务场景，在一个一个业务场景中进行领域分析与建模，这样的业务场景被称为“问题子域”。

领域驱动核心的设计思想就是将软件的分析与设计还原到真实世界中，真实世界中的业务与问题叫做“问题域”，业务逻辑与知识叫“业务领域知识”。

比如：

电商网站的问题域：用户如何进行在线购物，购物的流程是怎样的。
在线订餐系统的问题域：用户如何在线订餐，饭店如何在线接单，系统如何分配骑士配送。

而电商网站又能拆分出用户选购、下单、支付、物流等多个子域，订餐系统也能拆分出用户下单、饭店接单、其实配送等子域。如果一个子域比较复杂，我们还能将一个子域拆封成更多的子域。

一个复杂系统的领域驱动设计，就是以子域为中心，进行领域建模，绘制出一张张的领域模型设计，称之为“限界上下文”（Context Bounds，CB）。

DDD的限界上下文的设计，就体现了高质量软件设计中“单一职责原则“，也就是每个限界上下文中实现的都是软件变化同一个原因的业务。如果用户下单限界上下文有业务变化，还需要对它进行修改就行了，与其他限界上下文无关，这样就缩小了代码修改的范围，维护成本就降低了。

限界上下文之间存在相互关系，这种关系被称为“上下文地图（Context Map）”。

限界上下文之间可能存在的关系：
- 合作关系（Partnership）：两个上下文紧密合作的关系，一荣俱荣，一损俱损
- 共享内核（shared kernel）：两个上下文依赖部分共享的模型
- 客户方-供应方开发（Customer-Supplier Development）：上下文之间有组织的上下游依赖
- 遵奉者（Conformist）：下游上下文只能盲从上游上下文
- 防腐层（Anticorruption Layer）：一个上下文通过一些适配和转换与另一个上下文交互
- 开放主机服务（Open Host Service）：定义一种协议来让其他上下文来对本上下文进行访问
- 发布语言（Published Language）：通常与OHS一起使用，用于定义开放主机的协议。
- 大泥球（big ball of mud）：混杂在一起的上下文关系，边界不清晰。
- 另谋他路（SeparateWay）：两个完全没有任何关系的上下文。

比如用户下单上下文中，存在用户信息的读取，但是用户信息读取不应该在用户下单上下文中实现，因为用户下单业务的变更，不应该影响用户信息读取，所以用户信息的操作应该交给“用户信息管理”上下文，用户下单上下文只需要调用用户信息管理的用户信息读取接口。这个调用关系就是上下文地图的一部分。

**限界上下文内的高内聚**，每个限界上下文内实现的功能，都是软件变化的同一个原因的代码，因为这个原因的变化，才需要修改这个限界上下文。

**限界上下文可以作为拆分微服务的原则，每个限界上下文对应一个微服务。这样在日后的每次需求变更时，可以快速的落到某个微服务中变更，实现了低成本维护和快 速交付**

比如电商系统，根据限界上下文拆分出商品、购物、下单、支付、物流等微服务。

**限界上下文间的低耦合**，限界上下文通过上下文地图相互调用时，通过接口进行调用。通过接口解开调用方与被调用方之间的耦合。

通过微服务来实现“限界上下文”之间的低耦合，比如下单微服务需要调用支付微服务，首先在下单微服务中增加支付接口，在下单微服务中，所有对支付服务的调用都是对其支付接口的调用，接着在其他支付微服务中实现支付，比如现在设计了微信支付微服务和支付宝支付微服务，在系统运行时，需要那种支付方式，就调用哪个支付微服务，这样下单和支付之间的耦合就被解开了。

## 如何解决微服务拆分难题

**微服务做到小而专、高内聚的最佳实践是DDD**

- 从DDD开始需求分析、领域建模，逐渐建立起多个问题子域
- 将问题子域落实到限界上下文，它们之间的关系形成上下文地图
- 各子域落实到微服务中贫血模型或充血模型的设计，从而在微服务之间依据上下文地图形成接口

微服务设计最核心的难题是微服务的拆分，讲究小而专的设计，要低耦合、高内聚。

**领域驱动设计解决微服务如何拆分，实现微服务的高内聚于单一职责的问题**

**如何破局需求分析的困境？**

统一语言建模，技术去了解业务，咨询客户，探讨业务。注意捕获专业术语，学会用这些术语沟通。

召开事件风暴会议，在产品经理的引导下，业务和研发一起建模

事件风暴会议，要梳理当前业务中有哪些领域事件，命名时应当采取过去时态。领域事件时已经发生而且需要保存的事件。 

**微服务拆分原则--微服务内高内聚、微服务间低耦合**

- 微服务内高内聚，就是单一职责原则，将代码修改的范围缩小到这个微服务内。
- 微服务间低耦合，在微服务实现自身业务的过程中，如果需要执行的某些过程不是自己的职责，应当将这些过程交给其他微服务去实现，你只要对它的接口进行调用。

通过DDD进行业务建模，再基于领域模型进行限界上下文划分
能保证系统的设计，在限界上下文内高内聚，在限界上下文间低耦合。

**领域建模**是将一个系统划分成了多个子域，每个子域都是一个独立的业务场景，每个子域的实现就是“限界上下文”，他们之间的关联关系就是“上下文地图 ”





# 领域驱动模型实战

- DP：domain primivate，抽象并封装自检和一些隐性属性的计算逻辑，且这些属性是无状态的。
- Entity：抽象并封装单对象有状态的逻辑。
- Domain Service：抽象并封装多对象的有状态逻辑。
- Repository：抽象并封装外部数据访问的逻辑。

步骤：
1. 首先对需要处理的业务问题进行总览。UL 统一语言建模
2. 然后领域驱动对象（Entity）进行划分，明确每个领域驱动对象的包含的信息和职责边界。并进行跨对象，多对象的逻辑组织。
3. 接着在上层应用中根据业务描述去编排Entity和Domain Service。
4. 最后再做一些下水道工作，去对下层的数据访问、RPC调用做具体实现。






https://www.bilibili.com/video/BV1PM4y1L7Nh?p=7  10:30
