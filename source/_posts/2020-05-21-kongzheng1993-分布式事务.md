---
title: 分布式事务
excerpt: ''
tags: [分布式]
categories: [分布式]
comments: true
date: 2020-05-21 00:30:52
---

### 解决方案：
1. **通过mq**： 当A成功后，发送消息到mq，B消费消息，即使失败了，也能通过mq重试，知道B也成功，最终数据一致。**这里要注意发送消息最好在本地事务提交之后进行。** 但是还有问题，如果本地事务成功了，消息发送失败了呢？不能保证本地事务和发送消息两个操作同时都成功，这种方式存在问题！
2. **2PC--两阶段提交**： 也是通过mq发送消息给B，不过发送都是事务消息，Kafka和RocketMQ支持事务消息。先发送perpare消息，等待A本地事务执行后，根据本地事务执行情况发送commit或rollback。即使本地事务执行后，发送commit或rollback失败了，rocketmq在没收到下一步操作的情况下，会回溯事务是否成功，进而设置自己的perpare消息是否可消费。也存在问题，就是A成功的情况下，B必须要成功，但是B也会存在失败的情况，这里没办法进行处理。
3. **AT--业务无侵入**： 引入TxManager（事务管理器）来管理多个本地事务。各个本地事务提交前通知TxManager，由TxManager根据各个本地事务的情况来发出commit/rollback指令。大概思路就是写一个切面，在@Transaction的方法前执行创建事务组，通过netty等通信框架传给TxManager，然后执行本地事务代码，重写数据库连接commit方法（通过自定义数据库连接），让本地事务在commit前等待，根据本地事务执行情况，提交commit或者rollback结果到TxManager。TxManager在接收到所有本地事务的结构后，计算出commit还是rollback，发送指令到各个服务。

```java
@Aspect
@Component
public class TransactionGroupAspect implements Order {
    @Around("@annotation(xxx.TransactionGroup)")
    public void invoke(ProceedingJoinPoint point) {
        //1. 在TxManager创建事务组，返回事务组ID
        String transactionGroupId = ...
        //2. 执行本地事务
        try {
            //执行本地事务--@Transaction方法
            point.proceed();
            //提交执行成功结果，此时并没有提交，而是卡在我们重写的数据库连接的commit方法。
            ...send commit message
        } catch (Throwable throwable) {
            //发送rollback消息
            ...send rollback message
        }
        //记录本地事务的transactionGroupId，待唤醒提交线程的时候使用
        transactionMap.put(transactionGroupId, 本地事务对象)
    }
}
```

```java
@Override
public void commit() throws SQLException {
    //单独起一个线程，让TransactionGroupAspect的逻辑可以继续往下执行。。。发送消息到TxManager
    new Thread(new Runnable() {
        @Override
        public void run() {
            try{
                //本地事务提交前阻塞当前线程，等待TxManager发送指令来唤醒
                condition.await();
                //判断TxManager指令
                if (command.equals("commit")) {
                    //调用commit()，提交本地事务。
                    connection.commit();
                } else {
                    //回滚
                    connection.rollback();
                }
            }
        }
    }).start();
}
```

```java
//接收TxManager指令
...readFromChannel
//从本地事务集合中取出之前创建的本地事务
localTransaction = transactionMap.get(transactionGroupId);
//给本地事务指定将要执行的指令
localTransaction.setCommand(commandFromTxManager);
//唤醒之前阻塞在commit()前的线程，根据TxManager指令来提交或者回滚
localTransaction.getCondition.signal();

```


4. **TCC--业务有侵入**： try-commit-cancel，也是2pc，两阶段提交的方案。
5. **Saga--业务有侵入**： 金融行业的“冲正”
6. 