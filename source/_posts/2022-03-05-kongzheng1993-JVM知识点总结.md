---
title: JVM知识点总结
excerpt: 'JVM'
tags: [JVM]
categories: [JVM]
comments: true
date: 2022-03-05 18:30:52
---

Class文件、类加载子系统、运行时数据区、执行引擎、本地接口、本地方法栈

## Class文件

Class文件是一组以8字节为基础单位的二进制流。各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符。根据Java虚拟机规范的规定，Class文件结构采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构只有两种数据类型：无符号数（下面用u4表示4个字节的无符号数）和表。

<img src="Class.png"/>

构成：

1. 开头就是一个魔数（0xCAFEBABE 咖啡宝贝？），标识它是一个Class文件。（很多文件类型都有自己定义的魔术来表示自己的类型）。
2. 接下来是次版本号和主版本号，标识JDK的版本，为了解决JDK兼容性的问题。比如高版本的java代码无法在低版本的jdk上运行。
3. 下面是常量池计数器，记录后面常量池里面的常量的个数，常量池中有字面量和符号引用。字面量比较接近Java语言层面的常量概念，比如文本字符串、被声明为final的常量值等。符号引用则属于编译原理方面的概念，主要包括：
    - 被模块到处或者开放的包（Package）
    - 类和接口的全限定名
    - 字段的名称和描述符
    - 方法的名称和描述符
    - 方法句柄和方法类型
    - 动态调用点和动态变量
注： 常量池计数器是从1开始的，因为0的位置要留给没有父类的（Object类）、没有类名的（匿名内部类），索引要指向常量池第0个位置，也就是说0是留给无法指向的东西的。

4. 下面是访问标识，占用2个字节，用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类，是否声明为final；等等。一共有16个标志位可以使用，当前只定义了其中9个（ACC_PUBLIC、ACC_FINAL、ACC_SUPER、ACC_INTERFACE、ACC_ABSTRACT、ACC_SYNTHETIC、ACC_ANNOTATION、ACC_ENUM、ACC_MODULE），没有使用到的一律为0。
5. 类索引、父类索引与接口索引集合。由这三项确定该类型的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，java不允许多重继承，所以父类索引只有一个。除了Object外所有Java类都有父类，因此除了Object外所有Java类的父类索引都不为0。接口索引集合用来描述这个Class实现了那些接口，按照implements从左要右的顺序排列在接口索引集合中。类索引和父类索引各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。由于接口索引是一个集合，所以入口的第一项u2类型的数据为接口计数器（interface_count），表示索引表的容量，如果没有实现任何接口，则该计数器值为0，后面接口的索引表不在占用任何字节。
6. 字段表集合，用于描述接口或者类中声明的变量。Java语言中的字段包括类级变量以及实例级变量，但不包括在方法内部声明的变局部变量。字段表包括：access_flags、name—_index、descriptor_index、attributes_count、attributes。字段修饰符放在access_flags项目中，与类中的access_flags项目非常类似。根据语法规则，ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED只能三选一，ACC_FINAL和ACC_VOLATILE不能同时选择。接口之中的字段必须有ACC_PUBLIC、ACC_STATIC、ACC_FINAL标识。access_flags后面是两个索引值：name_index和descriptor_index，他们都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符。descriptor_index之后会跟随一个属性表集合，用于存储一些额外信息。
7. 方法表集合，和字段表类似，volatile和transient关键字不能修饰方法，所以方法表没有对应的访问标志；但是synchronized、native、strictfp（strict float point，精确浮点，可用于类、接口或者方法。）、abstract关键字可以修饰方法，所以增加了对应的访问标志。而我们编写在方法内的代码，在编译成字节码指令之后，就被保存在自己属性表的一个名为“Code”的属性里面，操作数栈的最大深度、局部变量表所需要的最大空间、整段代码的长度都会被保存到Code属性中，后面代码的执行都会用到。
8. 属性表，Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。属性表的数据项目不像其他部分要求严格的顺序、长度和内容，只要不与已有属性名重复即可。

## 类加载子系统

### JVM类加载的流程  

加载、链接（验证、准备、解析）、初始化，根据时间顺序其实是下面的过程：

   1. 加载：静态加载，java文件编译为class文件，二进制字节流加载。第一次加载的获得的是一个二进制字节流
   2. 验证：验证文件类型，魔术+主次版本号
   3. 加载：通过文件类型验证后，将字节流所代表的静态存储结构转化为方法区的运行时数据结构。class文件的常量池和运行时数据区中的常量池有什么区别和联系？
   4. 加载：在Java堆内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
   5. 验证：元数据验证
   6. 验证：字节码验证
   7. 准备：正式为类定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值（零值）的阶段。
   8. 初始化：最后一个步骤，开始执行类中编写的Java程序代码，执行类构造器`<clinit>()`方法的过程，这个构造器并不是程序员编写的那个，而是编译器在编译过程中收集的所有初始化代码（包括类变量的赋值动作和静态语句块中的语句，顺序是和源文件中的顺序一致），会先执行父类的`<clinit>()`，JVM为了保证一个类的`<clinit>()`方法在多线程的环境中正确执行会加锁同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行，其他线程都会阻塞，知道活动线程执行完毕。
注：解析是Java虚拟机将常量池内的符号引用替换为直接引用的过程，这个动作可能是随着类加载一直在做的，但是解析一定会在初始化之前完成。

### 类加载器 && 双亲委派模型

类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个而动作被放到JVM外部去实现，以便让应用程序自己决定如何去加载所需要的类，实现这个动作的代码被称为`类加载器`。

类加载器的作用并不只是加载类，还作用域确立一个类在JVM中的唯一性。

站在JVM的角度来看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器由C++实现，是虚拟机自身的一部分；另一种就是其他所有的类加载器，这些类加载器都是由Java实现，独立存在于虚拟机之外，全部继承自抽象类java.lang.ClassLoader。

三个系统提供的类加载器：

- 启动类加载器（Bootstrap ClassLoader），负责加载存放在




https://www.bilibili.com/video/BV1RP4y1E7pA?spm_id_from=333.999.0.0  15:44

