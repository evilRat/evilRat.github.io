---
title: JVM结构
excerpt: ''
tags: [Java]
categories: [Java]
comments: true
date: 2020-04-20 00:30:52
---


## JVM结构图

<img src="20170513134212845.png">

## 解析

### 四大部分

- **Class Loader（类加载器）** 就是将Class文件加载到内存，再说的详细一点就是，把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。

- **Run Data Area（运行时数据区）** 就是我们常说的JVM管理的内存了，也是我们这里主要讨论的部分。运行数据区是整个JVM的重点。我们所有写的程序都被加载到这里，之后才开始运行。这部分也是我们这里将要讨论的重点。

- **Execution engine（执行引擎）** 是Java虚拟机最核心的组成部分之一。执行引擎用于执行指令，不同的java虚拟机内部实现中，执行引擎在执行Java代码的时候可能有解释执行（解释器执行）和编译执行（通过即时编译器产生本地代码执行，例如BEA JRockit），也有可能两者兼备。任何JVM specification实现(JDK)的核心都是Execution engine，不同的JDK例如Sun 的JDK 和IBM的JDK好坏主要就取决于他们各自实现的Execution engine的好坏。

- **Native interface** 与native libraries交互，是其它编程语言交互的接口。当调用native方法的时候，就进入了一个全新的并且不再受虚拟机限制的世界，所以也很容易出现JVM无法控制的native heap OutOfMemory。

### Run Data Area

<table width="802" cellspacing="1" cellpadding="1" border="1" align="center">
    <tbody>
        <tr>
            <td align="center">数据</td>
            <td align="center">描述</td>
        </tr>
        <tr>
            <td>Program Counter Register</td>
            <td>程序计数器，
                <span>线程私有</span>、指向下一条要很执行的指令
            </td>
        </tr>
        <tr>
            <td>Java Stack</td>
            <td>Java虚拟机栈，
                <span>线程私有</span>，生命周期与线程相同。描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于
                <span>存储局部变量表、操作栈、动态链接、方法出口</span>
            </td>
        </tr>
        <tr>
            <td>Native Method Stack</td>
            <td>为虚拟机使用到的Native 方法服务</td>
        </tr>
        <tr>
            <td>Heap</td>
            <td>
                <span>线程共享</span>，由于现在收集器基本采用的分代收集算法，所以Java堆中还可以细分：新生代和老生代；更细致一点的有Eden空间、From Survivor空间、To Survivor空间等。
                <span>所有的对象实例以及数组都要在堆上分配</span>，是垃圾收集器管理的主要区域
            </td>
        </tr>
        <tr>
            <td>Method Area</td>
            <td>方法区，别名叫做非堆(Non-Heap)，
                <span>线程共享的内存区域</span>。目的是与Java堆区分开来，
                <span>存储类信息、常量、静态变量、即时编译器编译后的代码</span>。
                <br>
方法区存放的信息包括：
                    <br>
                        <strong>A 类的基本信息：</strong>
                        <br>
1.每个类的全限定名 
                            <br>
2.每个类的直接超类的全限定名(可约束类型转换) 
                                <br>
3.该类是类还是接口 
                                    <br>
4.该类型的访问修饰符 
                                        <br>
5.直接超接口的全限定名的有序列表 
                                            <br>
                                                <strong>B 已装载类的详细信息</strong>
                                                <br>
1.运行时常量池：在方法区中，每个类型都对应一个常量池，存放该类型所用到的所有常量，常量池中存储了诸如文字字符串、final变量值、类名和方法名常量。它们以数组形式通过索引被访 问，是外部调用与类联系及类型对象化的桥梁。（存的可能是个普通的字符串，然后经过常量池解析，则变成指向某个类的引用）
                                                    <br>
2.字段信息：字段信息存放类中声明的每一个字段的信息，包括字段的名、类型、修饰符。字段名称指的是类或接口的实例变量或类变量，字段的描述符是一个指示字段的类型的字符串，如private A a=null;则a为字段名，A为描述符，private为修饰符。
                                                        <br>
3.方法信息：类中声明的每一个方法的信息，包括方法名、返回值类型、参数类型、修饰符、异常、方法的字节码。(在编译的时候，就已经将方法的局部变量、操作数栈大小等确定并存放在字节码中，在装载的时候，随着类一起装入方法区。)
                                                            <br>
4.静态变量：就是类变量，类的所有实例都共享，我们只需知道，在方法区有个静态区，静态区专门存放静态变量和静态块。 
                                                                <br>
5.到类classloader的引用：到该类的类装载器的引用。 
                                                                    <br>
6.到类class 的引用：jvm为每个加载的类型(译者：包括类和接口)都创建一个java.lang.Class的实例。而jvm必须以某种方式把Class的这个实例和存储在方法区中的类型数据联系起来。
                                                                    </td>
                                                                </tr>
                                                            </tbody>
                                                        </table>

                                                     



