---
title: Java是值传递的！
excerpt: ''
tags: [Java]
categories: [Java]
comments: true
date: 2020-04-19 00:30:52
---

上周五边喝茶边吃瓜子在家办公，写一个接口，调用方请求过来之后，我需要在请求报文一个节点下加入两个字段，然后继续调用底层接口。随手就写下了下面的代码：

```java
Map params = inputObject.getParams();
Map reqInfoMap = params.get("reqInfo");
reqInfoMap.put("xxx", "XXX");
reqInfoMap.put("yyy", "YYY");

service.invoke(params);
```

我这里直接在请求实体对象中取出`params`，然后在`params`中取出`reqInfo`节点，接着在`reqInfo`节点下加入两个字段，紧接着就调用了底层服务，将`params`传出去了，后面测试我这也没有问题，两个字段都加上了。

可是大学我们就知道Java是值传递的了，我这里从`params`里get出来的值应该是一个`对象副本`啊，不应该是那个真正的对象啊，我对`对象副本`做出的修改，不应该影响原来的对象啊。。。

- **值传递（pass by value）** 是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。
- **引用传递（pass by reference）** 是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。


这里一阵慌张，难道jvm自己优化了？查了很多资料也没发现jvm对这块有啥优化。

我决定深挖一下Java参数传递的秘密。

看了阿里大佬[Hollis](https://www.zhihu.com/people/hollis-11)在知乎的回答，一下子恍然大悟。

**所以说，Java中其实还是值传递的，只不过对于对象参数，值的内容是对象的引用。**

其实很多人的疑惑都是对象的传递问题，对象的传递给人的感觉就像是引用传递似的。

下面两张图可以说明：

<img src="2.png">
<br>
<br>
<img src="1.jpg">

如果上面没有new这个动作，也就是没有把user这个变量指向一个新的内存地址，那么函数内的操作都是针对原内存地址的。但是这里new了一下，user指向了一个新的内存地址，后面针对user的操作都是针对新的内存地址的，所以原来的对象就不会受到影响了。

无论是值传递还是引用传递，其实都是一种求值策略(Evaluation strategy)。在求值策略中，还有一种叫做**按共享传递(call by sharing)**。**其实Java中的参数传递严格意义上说应该是按共享传递**。

按共享传递，是指在调用函数时，传递给函数的是**实参的地址的拷贝（如果实参在栈中，则直接拷贝该值）**。在函数内部对参数进行操作时，需要先拷贝的地址寻找到具体的值，再进行操作。如果该值在栈中，那么因为是直接拷贝的值，所以函数内部对参数进行操作不会对外部变量产生影响。如果原来拷贝的是原值在堆中的地址，那么需要先根据该地址找到堆中对应的位置，再进行操作。因为传递的是地址的拷贝所以函数内对值的操作对外部变量是可见的。简单点说，Java中的传递，是值传递，而这个值，实际上是对象的引用。而按共享传递其实只是按值传递的一个特例罢了。所以我们可以说Java的传递是按共享传递，或者说Java中的传递是值传递。

这里要注意String作为对象，传入方法后，在方法中执行类似`str = "ttt";`的代码，并不会改变实际参数的值，这是因为`str = "ttt";`其实执行了`str = new String("ttt");`，是新创建了一个对象，而不是修改之前的对象，所以实际参数并没有被修改。